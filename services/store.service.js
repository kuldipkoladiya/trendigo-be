/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import ApiError from 'utils/ApiError';
import httpStatus from 'http-status';
import { Store, BusinessCategory, SellerUser } from 'models';
import { logger } from '../config/logger';

export async function getStoreById(id, options = {}) {
  const store = await Store.findById(id, options.projection, options);
  return store;
}

export async function getOne(query, options = {}) {
  const store = await Store.findOne(query, options.projection, options);
  return store;
}

export async function getStoreList(filter, options = {}) {
  const store = await Store.find(filter, options.projection, options);
  return store;
}

export async function getStoreListWithPagination(filter, options = {}) {
  const store = await Store.paginate(filter, options);
  return store;
}

export async function createStore(body, options = {}) {
  if (body.businessCategoryId) {
    const businessCategoryId = await BusinessCategory.findOne({ _id: body.businessCategoryId });
    if (!businessCategoryId) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'field businessCategoryId is not valid');
    }
  }
  if (body.contact) {
    const contact = await SellerUser.findOne({ _id: body.contact });
    if (!contact) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'field contact is not valid');
    }
  }
  try {
    const store = await Store.create(body);
    return store;
  } catch (error) {
    logger.error('error in creating store:', error);
    if (error.name === 'MongoError' && error.code === 11000) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'You are trying to create duplicate entry!');
    } else {
      throw new ApiError(httpStatus.BAD_REQUEST, error.message);
    }
  }
}

export async function updateStore(filter, body, options = {}) {
  if (body.businessCategoryId) {
    const businessCategoryId = await BusinessCategory.findOne({ _id: body.businessCategoryId });
    if (!businessCategoryId) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'field businessCategoryId is not valid');
    }
  }
  if (body.contact) {
    const contact = await SellerUser.findOne({ _id: body.contact });
    if (!contact) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'field contact is not valid');
    }
  }
  try {
    const store = await Store.findOneAndUpdate(filter, body, options);
    return store;
  } catch (error) {
    logger.error('error in creating store:', error);
    if (error.name === 'MongoError' && error.code === 11000) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'You are trying to create duplicate entry!');
    } else {
      throw new ApiError(httpStatus.BAD_REQUEST, error.message);
    }
  }
}

export async function updateManyStore(filter, body, options = {}) {
  try {
    const store = await Store.updateMany(filter, body, options);
    return store;
  } catch (error) {
    logger.error('error in creating store:', error);
    if (error.name === 'MongoError' && error.code === 11000) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'You are trying to create duplicate entry!');
    } else {
      throw new ApiError(httpStatus.BAD_REQUEST, error.message);
    }
  }
}

export async function removeStore(filter) {
  const store = await Store.findOneAndRemove(filter);
  return store;
}

export async function removeManyStore(filter) {
  const store = await Store.deleteMany(filter);
  return store;
}

export async function aggregateStore(query) {
  const store = await Store.aggregate(query);
  return store;
}

export async function aggregateStoreWithPagination(query, options = {}) {
  const aggregate = Store.aggregate();
  query.map((obj) => {
    aggregate._pipeline.push(obj);
  });
  const store = await Store.aggregatePaginate(aggregate, options);
  return store;
}
