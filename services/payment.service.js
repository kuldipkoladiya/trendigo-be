/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import ApiError from 'utils/ApiError';
import httpStatus from 'http-status';
import { Payment, Order } from 'models';

export async function getPaymentById(id, options = {}) {
  const payment = await Payment.findById(id, options.projection, options);
  return payment;
}

export async function getOne(query, options = {}) {
  const payment = await Payment.findOne(query, options.projection, options);
  return payment;
}

export async function getPaymentList(filter, options = {}) {
  const payment = await Payment.find(filter, options.projection, options);
  return payment;
}

export async function getPaymentListWithPagination(filter, options = {}) {
  const payment = await Payment.paginate(filter, options);
  return payment;
}

export async function createPayment(body, options = {}) {
  if (body.ordeId) {
    const ordeId = await Order.findOne({ _id: body.ordeId });
    if (!ordeId) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'field ordeId is not valid');
    }
  }
  const payment = await Payment.create(body);
  return payment;
}

export async function updatePayment(filter, body, options = {}) {
  if (body.ordeId) {
    const ordeId = await Order.findOne({ _id: body.ordeId });
    if (!ordeId) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'field ordeId is not valid');
    }
  }
  const payment = await Payment.findOneAndUpdate(filter, body, options);
  return payment;
}

export async function updateManyPayment(filter, body, options = {}) {
  const payment = await Payment.updateMany(filter, body, options);
  return payment;
}

export async function removePayment(filter) {
  const payment = await Payment.findOneAndRemove(filter);
  return payment;
}

export async function removeManyPayment(filter) {
  const payment = await Payment.deleteMany(filter);
  return payment;
}

export async function aggregatePayment(query) {
  const payment = await Payment.aggregate(query);
  return payment;
}

export async function aggregatePaymentWithPagination(query, options = {}) {
  const aggregate = Payment.aggregate();
  query.map((obj) => {
    aggregate._pipeline.push(obj);
  });
  const payment = await Payment.aggregatePaginate(aggregate, options);
  return payment;
}
